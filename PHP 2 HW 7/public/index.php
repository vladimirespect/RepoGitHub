<?php

session_start();

use app\engine\{Autoload, Render, TwigRender, Request};
//такой список работает в версиях старше 7й



//TODO сделать путь абсолютным
//нужно присвоить неймспейс каждому классу, который соответсвует пути где лежит этот файл+1 папка сверху 'app' во избежании конфлика с библиотеками
//каждому классу соответствует своя страница с именем кк у класса
//каждому образцу вместо длинного имени с полным путём к виртуальной папке обьявить пссевдоним в начале кода через use.
include "../config/config.php";
//include "../engine/Autoload.php"; после добавления автозагрузчика phpunit с папки vendor после редактирования composer
//необходимость в нашем автозагрузчике отпала
include "../vendor/autoload.php";

//try catch - перхват фатала. Нужен для поиска ошибок во время разработки.
// А тесты при добавлении функционала. Кетч ловит ошибку в любом месте проекта. Если ошибок нет просто выдаст страницу как обычно

try {
    spl_autoload_register([new Autoload(), 'loadClass']); //требует два параметра 1) экземпляр класса автозагрузчика, 2) имя метода его класса отвечающего за загрузку
//плюс в том что создаётся всего один экземпляр автозагрузчика

//ЧПУ    //настройка ЧПУ сделана в файле public/.htaccess под сервер apache

//Создаём объект класса реквест
    $request = new Request();
//Вызывается его конструктор который автоматически через глобальные переменные сохранит значение запроса пользователя в своих полях

//через методы гет вытаскиваем значения полей с Реквеста для передачи управления соответствующему контроллеру
    $controllerName = $request->getControllerName() ?: 'product'; //если значения не будет, ставим по умолчанию product пока что//$url[1] ?? 'product'; - с такой записью не работала главная, переписали на тернарный иф
    $actionName = $request->getActionName();//имя экшена от пользователя

    $controllerClass = CONTROLLER_NAMESPACE . ucfirst($controllerName) . "Controller";
//ucfirst($controllerName) - делает заглавной первую букву для имени класса, пришедшего из url
    if (class_exists($controllerClass)) { //проверяем ведь данные пришли от пользователя
        $controller = new $controllerClass(new Render()); //через переменную переменных, создадим динамически объект класса по имени класса от пользователя
        //new $controllerClass(new TwigRender()); - в этом поле теперь можем переключать рендер. В скобочках создаётся объект класса рендер который рендерит шаблоны
        $controller->runAction($actionName);
    }

    /*Создаётся контроллер в зависимости от того какую страницу хочет пользователь, находится нужный класс,
    создаётся его экземпляр, в нём вызывается метод Render
    При создании экземпляра в конструктор подставляется экземпляр Twig*/

} catch (\PDOException $exception) { //можем последовательно ловить и отлаживать разные исключения, как здесь в ПДО
    var_dump($exception->getMessage()); //в engine class Request приведён пример как унаследоваться от exception чтобы делать так в своих классах

} catch (\Exception $exception) { //главное не забывать что исключения \Exception должны идти после всех остальных
    var_dump($exception->getTrace());
    //если хотим вникнуть читаем Котерова
}
